package me.madcat.features.modules.exploit;

import io.netty.util.internal.ConcurrentSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import me.madcat.event.events.MoveEvent;
import me.madcat.event.events.PacketEvent;
import me.madcat.event.events.PushEvent;
import me.madcat.event.events.UpdateWalkingPlayerEvent;
import me.madcat.features.modules.Module;
import me.madcat.features.setting.Setting;
import me.madcat.util.EntityUtil;
import me.madcat.util.Timer;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class TestPacketFly
extends Module {
    private static TestPacketFly instance;
    private final Set<CPacketPlayer> packets = new ConcurrentSet();
    private final Map<Integer, IDtime> teleportmap = new ConcurrentHashMap<>();
    public final Setting<Boolean> flight = this.register(new Setting<>("Flight", true));
    public final Setting<Integer> flightMode = this.register(new Setting<>("FMode", 0, 0, 1));
    public final Setting<Boolean> doAntiFactor = this.register(new Setting<>("Factorize", true));
    public final Setting<Double> antiFactor = this.register(new Setting<>("AntiFactor", 2.5, 0.1, 3.0));
    public final Setting<Double> extraFactor = this.register(new Setting<>("ExtraFactor", 1.0, 0.1, 3.0));
    public final Setting<Boolean> strafeFactor = this.register(new Setting<>("StrafeFactor", true));
    public final Setting<Integer> loops = this.register(new Setting<>("Loops", 1, 1, 10));
    public final Setting<Boolean> clearTeleMap = this.register(new Setting<>("ClearMap", true));
    public final Setting<Integer> mapTime = this.register(new Setting<>("ClearTime", 30, 1, 500));
    public final Setting<Boolean> clearIDs = this.register(new Setting<>("ClearIDs", true));
    public final Setting<Boolean> setYaw = this.register(new Setting<>("SetYaw", true));
    public final Setting<Boolean> setID = this.register(new Setting<>("SetID", true));
    public final Setting<Boolean> setMove = this.register(new Setting<>("SetMove", false));
    public final Setting<Boolean> nocliperino = this.register(new Setting<>("NoClip", false));
    public final Setting<Boolean> sendTeleport = this.register(new Setting<>("Teleport", true));
    public final Setting<Boolean> setPos = this.register(new Setting<>("SetPos", false));
    public final Setting<Boolean> invalidPacket = this.register(new Setting<>("InvalidPacket", true));
    private int flightCounter = 0;
    private int teleportID = 0;

    public TestPacketFly() {
        super("TestPacketFly", "Uses packets to fly!", Module.Category.EXPLOIT);
        instance = this;
    }

    public static TestPacketFly INSTANCE() {
        if (instance == null) {
            instance = new TestPacketFly();
        }
        return instance;
    }

    @Override
    public void onTick() {
        this.teleportmap.entrySet().removeIf(this::onTick0);
    }

    @SubscribeEvent
    public void onUpdateWalkingPlayer(UpdateWalkingPlayerEvent updateWalkingPlayerEvent) {
        double d = 0;
        if (updateWalkingPlayerEvent.getStage() == 1) {
            return;
        }
        TestPacketFly.mc.player.setVelocity(0.0, 0.0, 0.0);
        boolean bl = this.checkHitBoxes();
        double d2 = TestPacketFly.mc.player.movementInput.jump && (bl || !EntityUtil.isMoving()) ? (this.flight.getValue() && !bl ? (this.flightMode.getValue() == 0 ? (this.resetCounter(10) ? -0.032 : 0.062) : (this.resetCounter(20) ? -0.032 : 0.062)) : 0.062) : (TestPacketFly.mc.player.movementInput.sneak ? -0.062 : (!bl ? (this.resetCounter(4) ? (this.flight.getValue() ? -0.04 : 0.0) : 0.0) : (d = 0.0)));
        double[] dArray = this.getMotion(this.strafeFactor.getValue() && bl ? 0.031 : 0.26);
        for (int i = 1; i < this.loops.getValue() + 1; ++i) {
            TestPacketFly.mc.player.motionX = dArray[0] * (double)i * this.extraFactor.getValue();
            TestPacketFly.mc.player.motionY = d * (double)i;
            TestPacketFly.mc.player.motionZ = dArray[1] * (double)i * this.extraFactor.getValue();
            this.sendPackets(TestPacketFly.mc.player.motionX, TestPacketFly.mc.player.motionY, TestPacketFly.mc.player.motionZ, this.sendTeleport.getValue());
        }
    }

    @SubscribeEvent
    public void onMove(MoveEvent moveEvent) {
        if (this.setMove.getValue() && this.flightCounter != 0) {
            moveEvent.setX(TestPacketFly.mc.player.motionX);
            moveEvent.setY(TestPacketFly.mc.player.motionY);
            moveEvent.setZ(TestPacketFly.mc.player.motionZ);
            if (this.nocliperino.getValue() && this.checkHitBoxes()) {
                TestPacketFly.mc.player.noClip = true;
            }
        }
    }

    @SubscribeEvent
    public void onPacketSend(PacketEvent.Send send) {
        CPacketPlayer cPacketPlayer;
        if (send.getPacket() instanceof CPacketPlayer && !this.packets.remove(cPacketPlayer = send.getPacket())) {
            send.setCanceled(true);
        }
    }

    @SubscribeEvent
    public void onPushOutOfBlocks(PushEvent pushEvent) {
        if (pushEvent.getStage() == 1) {
            pushEvent.setCanceled(true);
        }
    }

    @SubscribeEvent
    public void onPacketReceive(PacketEvent.Receive receive) {
        if (receive.getPacket() instanceof SPacketPlayerPosLook && !TestPacketFly.fullNullCheck()) {
            SPacketPlayerPosLook sPacketPlayerPosLook = receive.getPacket();
            if (TestPacketFly.mc.player.isEntityAlive() && TestPacketFly.mc.world.isBlockLoaded(new BlockPos(TestPacketFly.mc.player.posX, TestPacketFly.mc.player.posY, TestPacketFly.mc.player.posZ), false) && !(TestPacketFly.mc.currentScreen instanceof GuiDownloadTerrain) && this.clearIDs.getValue()) {
                this.teleportmap.remove(sPacketPlayerPosLook.getTeleportId());
            }
            if (this.setID.getValue()) {
                this.teleportID = sPacketPlayerPosLook.getTeleportId();
            }
        }
    }

    private boolean checkHitBoxes() {
        return !TestPacketFly.mc.world.getCollisionBoxes(TestPacketFly.mc.player, TestPacketFly.mc.player.getEntityBoundingBox().expand(-0.0625, -0.0625, -0.0625)).isEmpty();
    }

    private boolean resetCounter(int n) {
        if (++this.flightCounter >= n) {
            this.flightCounter = 0;
            return true;
        }
        return false;
    }

    private double[] getMotion(double d) {
        float f = TestPacketFly.mc.player.movementInput.moveForward;
        float f2 = TestPacketFly.mc.player.movementInput.moveStrafe;
        float f3 = TestPacketFly.mc.player.prevRotationYaw + (TestPacketFly.mc.player.rotationYaw - TestPacketFly.mc.player.prevRotationYaw) * mc.getRenderPartialTicks();
        if (f != 0.0f) {
            if (f2 > 0.0f) {
                f3 += (float)(f > 0.0f ? -45 : 45);
            } else if (f2 < 0.0f) {
                f3 += (float)(f > 0.0f ? 45 : -45);
            }
            f2 = 0.0f;
            if (f > 0.0f) {
                f = 1.0f;
            } else if (f < 0.0f) {
                f = -1.0f;
            }
        }
        double d2 = (double)f * d * -Math.sin(Math.toRadians(f3)) + (double)f2 * d * Math.cos(Math.toRadians(f3));
        double d3 = (double)f * d * Math.cos(Math.toRadians(f3)) - (double)f2 * d * -Math.sin(Math.toRadians(f3));
        return new double[]{d2, d3};
    }

    private void sendPackets(double d, double d2, double d3, boolean bl) {
        Vec3d vec3d = new Vec3d(d, d2, d3);
        Vec3d vec3d2 = TestPacketFly.mc.player.getPositionVector().add(vec3d);
        Vec3d vec3d3 = this.outOfBoundsVec(vec3d2);
        this.packetSender(new CPacketPlayer.Position(vec3d2.x, vec3d2.y, vec3d2.z, TestPacketFly.mc.player.onGround));
        if (this.invalidPacket.getValue()) {
            this.packetSender(new CPacketPlayer.Position(vec3d3.x, vec3d3.y, vec3d3.z, TestPacketFly.mc.player.onGround));
        }
        if (this.setPos.getValue()) {
            TestPacketFly.mc.player.setPosition(vec3d2.x, vec3d2.y, vec3d2.z);
        }
        this.teleportPacket(vec3d2, bl);
    }

    private void teleportPacket(Vec3d vec3d, boolean bl) {
        if (bl) {
            TestPacketFly.mc.player.connection.sendPacket(new CPacketConfirmTeleport(++this.teleportID));
            this.teleportmap.put(this.teleportID, new IDtime(vec3d, new Timer()));
        }
    }

    private Vec3d outOfBoundsVec(Vec3d vec3d) {
        return vec3d.add(0.0, 1337.0, 0.0);
    }

    private void packetSender(CPacketPlayer cPacketPlayer) {
        this.packets.add(cPacketPlayer);
        TestPacketFly.mc.player.connection.sendPacket(cPacketPlayer);
    }

    private boolean onTick0(Map.Entry entry) {
        return this.clearTeleMap.getValue() && ((IDtime)entry.getValue()).getTimer().passedS(this.mapTime.getValue());
    }

    public static class IDtime {
        private final Vec3d pos;
        private final Timer timer;

        public IDtime(Vec3d vec3d, Timer timer) {
            this.pos = vec3d;
            this.timer = timer;
            this.timer.reset();
        }

        public Vec3d getPos() {
            return this.pos;
        }

        public Timer getTimer() {
            return this.timer;
        }
    }
}

