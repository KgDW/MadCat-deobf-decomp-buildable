package me.madcat.features.modules.exploit;

import me.madcat.features.modules.Module;
import me.madcat.features.setting.Setting;
import me.madcat.util.BlockUtil;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.multiplayer.WorldClient;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

public class Phase
extends Module {
    final Setting<Mode> mode = this.register(new Setting<>("Mode", Mode.Stuck));
    final Setting<Boolean> onlyBurrow = this.register(new Setting<>("OnlyBurrow", Boolean.TRUE, this::new0));
    final Setting<Boolean> onBurrow = this.register(new Setting<>("OnBurrow", Boolean.FALSE, this::new1));
    final Setting<Double> offset2 = this.register(new Setting<>("Speed", 0.6, 0.1, 1.0, this::new2));
    final Setting<Integer> delay = this.register(new Setting<>("Delay", 1, 0, 10, this::new3));
    int tickTimer;
    final Setting<Boolean> toggle;
    final Setting<Integer> offset = this.register(new Setting<>("Offset", 1, 0, 10, this::new4));

    private boolean new0(Boolean bl) {
        return this.mode.getValue() == Mode.Skip;
    }

    public Phase() {
        super("Phase", "esu dog", Module.Category.EXPLOIT);
        this.toggle = this.register(new Setting<>("AutoToggle", Boolean.FALSE, this::new5));
    }

    public static double getDirection() {
        float f = Phase.mc.player.rotationYaw;
        if (Phase.mc.player.moveVertical < 0.0f) {
            f += 180.0f;
        }
        float f2 = 1.0f;
        if (Phase.mc.player.moveVertical < 0.0f) {
            f2 = -0.5f;
        } else if (Phase.mc.player.moveVertical > 0.0f) {
            f2 = 0.5f;
        }
        if (Phase.mc.player.moveStrafing > 0.0f) {
            f -= 90.0f * f2;
        }
        if (Phase.mc.player.moveStrafing < 0.0f) {
            f += 90.0f * f2;
        }
        return Math.toRadians(f);
    }

    private static Boolean onTick6(Block block) {
        return block != Blocks.AIR;
    }

    public static boolean collideBlockIntersects(final AxisAlignedBB axisAlignedBB, final Function1<? super Block, Boolean> function1) {
        final WorldClient world = Phase.mc.world;
        int i = (int)Math.floor(Phase.mc.player.getEntityBoundingBox().minX);
        while (i < (int)Math.floor(Phase.mc.player.getEntityBoundingBox().maxX) + 1) {
            final int n = i;
            ++i;
            int j = (int)Math.floor(Phase.mc.player.getEntityBoundingBox().minZ);
            while (j < (int)Math.floor(Phase.mc.player.getEntityBoundingBox().maxZ) + 1) {
                final int n2 = j;
                ++j;
                final BlockPos blockPos = new BlockPos(n, axisAlignedBB.minY, n2);
                final WorldClient world2 = Phase.mc.world;
                Block block;
                if (world2 == null) {
                    block = null;
                }
                else {
                    block = world2.getBlockState(blockPos).getBlock();
                }
                final Block block2 = block;
                if (function1.invoke(block2)) {
                    final WorldClient world3 = Phase.mc.world;
                    final IBlockState blockState = (world3 == null) ? null : world3.getBlockState(blockPos);
                    AxisAlignedBB axisAlignedBB2;
                    if (blockState == null) {
                        axisAlignedBB2 = null;
                    }
                    else {
                        axisAlignedBB2 = ((block2 == null) ? null : block2.getSelectedBoundingBox(blockState, world, blockPos));
                    }
                    final AxisAlignedBB axisAlignedBB3 = axisAlignedBB2;
                    if (axisAlignedBB3 == null) {
                        continue;
                    }
                    if (Phase.mc.player.getEntityBoundingBox().intersects(axisAlignedBB3)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    private boolean new3(Integer n) {
        return this.mode.getValue() == Mode.Skip;
    }

    private boolean new1(Boolean bl) {
        return !this.onlyBurrow.getValue() || this.mode.getValue() == Mode.Stuck;
    }

    @Override
    public void onTick() {
        if (this.mode.getValue() == Mode.Stuck) {
            double d = Math.abs(Phase.mc.player.posX) - Math.floor(Math.abs(Phase.mc.player.posX));
            double d2 = Math.abs(Phase.mc.player.posZ) - Math.floor(Math.abs(Phase.mc.player.posZ));
            if (d == 0.7 || d == 0.3 || d2 == 0.7 || d2 == 0.3 || !this.onBurrow.getValue() && !Phase.mc.world.getBlockState(BlockUtil.getFlooredPosition(Phase.mc.player)).getBlock().equals(Blocks.AIR)) {
                return;
            }
            Vec3d vec3d = Phase.mc.player.getPositionVector();
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(vec3d.add(new Vec3d(0.3 + (double) this.offset.getValue() / 100.0, 0.2, 0.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX + (double) this.offset.getValue() / 100.0, Phase.mc.player.posY, Phase.mc.player.posZ);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(vec3d.add(new Vec3d(-0.3 - (double) this.offset.getValue() / 100.0, 0.2, 0.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX - (double) this.offset.getValue() / 100.0, Phase.mc.player.posY, Phase.mc.player.posZ);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(vec3d.add(new Vec3d(0.0, 0.2, 0.3 + (double) this.offset.getValue() / 100.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX, Phase.mc.player.posY, Phase.mc.player.posZ + (double) this.offset.getValue() / 100.0);
                if (this.toggle.getValue()) {
                    this.disable();
                }
                return;
            }
            if (!Phase.mc.world.getBlockState(BlockUtil.vec3toBlockPos(vec3d.add(new Vec3d(0.0, 0.2, -0.3 - (double) this.offset.getValue() / 100.0)))).getBlock().equals(Blocks.AIR)) {
                Phase.mc.player.setPosition(Phase.mc.player.posX, Phase.mc.player.posY, Phase.mc.player.posZ - (double) this.offset.getValue() / 100.0);
                if (this.toggle.getValue()) {
                    this.disable();
                }
            }
        } else {
            ++this.tickTimer;
            boolean bl = Phase.collideBlockIntersects(Phase.mc.player.getEntityBoundingBox(), Phase::onTick6);
            if (!Phase.mc.player.onGround || this.tickTimer < this.delay.getValue() || !Phase.mc.player.collidedHorizontally) {
                return;
            }
            if (bl && !Phase.mc.player.isSneaking() && !this.onBurrow.getValue() && !this.onlyBurrow.getValue()) {
                return;
            }
            if (this.onlyBurrow.getValue() && !bl) {
                return;
            }
            double d = Phase.getDirection();
            double d3 = -Math.sin(d) * this.offset2.getValue();
            double d4 = Math.cos(d) * this.offset2.getValue();
            for (int i = 0; i < 3; ++i) {
                Phase.mc.player.connection.sendPacket(new CPacketPlayer.Position(Phase.mc.player.posX, Phase.mc.player.posY + 0.06, Phase.mc.player.posZ, true));
                Phase.mc.player.connection.sendPacket(new CPacketPlayer.Position(Phase.mc.player.posX + d3 * (double)i, Phase.mc.player.posY, Phase.mc.player.posZ + d4 * (double)i, true));
            }
            Phase.mc.player.setEntityBoundingBox(Phase.mc.player.getEntityBoundingBox().offset(d3, 0.0, d4));
            Phase.mc.player.setPositionAndUpdate(Phase.mc.player.posX + d3, Phase.mc.player.posY, Phase.mc.player.posZ + d4);
            this.tickTimer = 0;
        }
    }

    private boolean new4(Integer n) {
        return this.mode.getValue() == Mode.Stuck;
    }

    private boolean new5(Boolean bl) {
        return this.mode.getValue() == Mode.Stuck;
    }

    private boolean new2(Double d) {
        return this.mode.getValue() == Mode.Skip;
    }

    public interface Function {
    }

    public enum Mode {
        Stuck,
        Skip

    }

    public interface Function1<P1, R>
    extends Function {
        R invoke(P1 var1);
    }
}

