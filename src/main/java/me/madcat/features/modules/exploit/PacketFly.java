package me.madcat.features.modules.exploit;

import io.netty.util.internal.ConcurrentSet;
import java.util.Set;
import me.madcat.event.events.MoveEvent;
import me.madcat.event.events.PacketEvent;
import me.madcat.event.events.PushEvent;
import me.madcat.event.events.UpdateWalkingPlayerEvent;
import me.madcat.features.modules.Module;
import me.madcat.features.setting.Setting;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketEntityAction;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class PacketFly
extends Module {
    private static PacketFly INSTANCE = new PacketFly();
    private final Set<CPacketPlayer> packets = new ConcurrentSet();
    public final Setting<PacketFlyMode> type = this.register(new Setting<>("Type", PacketFlyMode.SETBACK));
    public final Setting<Integer> yMove = this.register(new Setting<>("YMove", 625, 1, 1000));
    public final Setting<Boolean> extra = this.register(new Setting<>("ExtraPacket", Boolean.TRUE));
    public final Setting<Integer> offset = this.register(new Setting<>("Offset", 1337, -1337, 1337));
    public final Setting<Boolean> fallPacket = this.register(new Setting<>("FallPacket", Boolean.TRUE));
    public final Setting<Boolean> teleporter = this.register(new Setting<>("Teleport", Boolean.TRUE));
    public final Setting<Boolean> boundingBox = this.register(new Setting<>("BoundingBox", Boolean.TRUE));
    public final Setting<Integer> teleportConfirm = this.register(new Setting<>("Confirm", 2, 0, 4));
    public final Setting<Boolean> ultraPacket = this.register(new Setting<>("DoublePacket", Boolean.FALSE));
    public final Setting<Boolean> updates = this.register(new Setting<>("Update", Boolean.FALSE));
    public final Setting<Boolean> setOnMove = this.register(new Setting<>("SetMove", Boolean.FALSE));
    public final Setting<Boolean> cliperino = this.register(new Setting<>("NoClip", Boolean.FALSE));
    public final Setting<Boolean> scanPackets = this.register(new Setting<>("ScanPackets", Boolean.FALSE));
    public final Setting<Boolean> resetConfirm = this.register(new Setting<>("Reset", Boolean.FALSE));
    public final Setting<Boolean> posLook = this.register(new Setting<>("PosLook", Boolean.FALSE));
    public final Setting<Boolean> cancel = this.register(new Setting<>("Cancel", Boolean.FALSE));
    public final Setting<Boolean> cancelType = this.register(new Setting<>("SetYaw", Boolean.FALSE));
    public final Setting<Boolean> onlyY = this.register(new Setting<>("OnlyY", Boolean.FALSE));
    public final Setting<Integer> cancelPacket = this.register(new Setting<>("Packets", 20, 0, 20));
    private boolean teleport = true;
    private int teleportIds = 0;
    private int posLookPackets;

    public PacketFly() {
        super("PacketFly", "Makes you able to PacketFly through blocks", Module.Category.EXPLOIT);
        this.setInstance();
    }

    public static PacketFly INSTANCE() {
        if (INSTANCE == null) {
            INSTANCE = new PacketFly();
        }
        return INSTANCE;
    }

    private void setInstance() {
        INSTANCE = this;
    }

    @Override
    public void onDisable() {
        this.packets.clear();
        this.posLookPackets = 0;
        if (PacketFly.mc.player != null) {
            if (this.resetConfirm.getValue()) {
                this.teleportIds = 0;
            }
            PacketFly.mc.player.noClip = false;
        }
    }

    @Override
    public String getDisplayInfo() {
        return "Phobos";
    }

    @SubscribeEvent
    public void onMove(MoveEvent moveEvent) {
        if (this.setOnMove.getValue() && this.type.getValue() == PacketFlyMode.SETBACK && moveEvent.getStage() == 0 && !mc.isSingleplayer()) {
            moveEvent.setX(PacketFly.mc.player.motionX);
            moveEvent.setY(PacketFly.mc.player.motionY);
            moveEvent.setZ(PacketFly.mc.player.motionZ);
            if (this.cliperino.getValue()) {
                PacketFly.mc.player.noClip = true;
            }
        }
        if (this.type.getValue() == PacketFlyMode.NONE || moveEvent.getStage() != 0 || mc.isSingleplayer()) {
            return;
        }
        if (!this.boundingBox.getValue() && !this.updates.getValue()) {
            this.doPacketFly(moveEvent);
        }
    }

    @SubscribeEvent
    public void onPush(PushEvent pushEvent) {
        if (pushEvent.getStage() == 1 && this.type.getValue() != PacketFlyMode.NONE) {
            pushEvent.setCanceled(true);
        }
    }

    @SubscribeEvent
    public void onMove(UpdateWalkingPlayerEvent updateWalkingPlayerEvent) {
        if (PacketFly.fullNullCheck() || updateWalkingPlayerEvent.getStage() != 0 || this.type.getValue() != PacketFlyMode.SETBACK) {
            return;
        }
        if (this.boundingBox.getValue()) {
            this.doBoundingBox();
        } else if (this.updates.getValue()) {
            this.doPacketFly(null);
        }
    }

    private void doPacketFly(MoveEvent moveEvent) {
        if (this.type.getValue() == PacketFlyMode.SETBACK && !this.boundingBox.getValue()) {
            CPacketPlayer.PositionRotation positionRotation;
            double[] dArray = this.getMotion(this.teleport ? (double) this.yMove.getValue() / 10000.0 : (double)(this.yMove.getValue() - 1) / 10000.0);
            double d = PacketFly.mc.player.posX + dArray[0];
            double d2 = PacketFly.mc.player.posY + (PacketFly.mc.gameSettings.keyBindJump.isKeyDown() ? (this.teleport ? (double) this.yMove.getValue() / 10000.0 : (double)(this.yMove.getValue() - 1) / 10000.0) : 1.0E-8) - (PacketFly.mc.gameSettings.keyBindSneak.isKeyDown() ? (this.teleport ? (double) this.yMove.getValue() / 10000.0 : (double)(this.yMove.getValue() - 1) / 10000.0) : 2.0E-8);
            double d3 = PacketFly.mc.player.posZ + dArray[1];
            CPacketPlayer.PositionRotation positionRotation2 = new CPacketPlayer.PositionRotation(d, d2, d3, PacketFly.mc.player.rotationYaw, PacketFly.mc.player.rotationPitch, false);
            this.packets.add(positionRotation2);
            PacketFly.mc.player.connection.sendPacket(positionRotation2);
            if (this.teleportConfirm.getValue() != 3) {
                PacketFly.mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportIds - 1));
                ++this.teleportIds;
            }
            if (this.extra.getValue()) {
                positionRotation = new CPacketPlayer.PositionRotation(PacketFly.mc.player.posX, (double) this.offset.getValue() + PacketFly.mc.player.posY, PacketFly.mc.player.posZ, PacketFly.mc.player.rotationYaw, PacketFly.mc.player.rotationPitch, true);
                this.packets.add(positionRotation);
                PacketFly.mc.player.connection.sendPacket(positionRotation);
            }
            if (this.teleportConfirm.getValue() != 1) {
                PacketFly.mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportIds + 1));
                ++this.teleportIds;
            }
            if (this.ultraPacket.getValue()) {
                positionRotation = new CPacketPlayer.PositionRotation(d, d2, d3, PacketFly.mc.player.rotationYaw, PacketFly.mc.player.rotationPitch, false);
                this.packets.add(positionRotation);
                PacketFly.mc.player.connection.sendPacket(positionRotation);
            }
            if (this.teleportConfirm.getValue() == 4) {
                PacketFly.mc.player.connection.sendPacket(new CPacketConfirmTeleport(this.teleportIds));
                ++this.teleportIds;
            }
            if (this.fallPacket.getValue()) {
                PacketFly.mc.player.connection.sendPacket(new CPacketEntityAction(PacketFly.mc.player, CPacketEntityAction.Action.START_FALL_FLYING));
            }
            PacketFly.mc.player.setPosition(d, d2, d3);
            boolean bl = this.teleport = !this.teleporter.getValue() || !this.teleport;
            if (moveEvent != null) {
                moveEvent.setX(0.0);
                moveEvent.setY(0.0);
                moveEvent.setX(0.0);
            } else {
                PacketFly.mc.player.motionX = 0.0;
                PacketFly.mc.player.motionY = 0.0;
                PacketFly.mc.player.motionZ = 0.0;
            }
        }
    }

    private void doBoundingBox() {
        double[] dArray = this.getMotion(this.teleport ? (double)0.0225f : (double)0.0224f);
        PacketFly.mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(PacketFly.mc.player.posX + dArray[0], PacketFly.mc.player.posY + (PacketFly.mc.gameSettings.keyBindJump.isKeyDown() ? (this.teleport ? 0.0625 : 0.0624) : 1.0E-8) - (PacketFly.mc.gameSettings.keyBindSneak.isKeyDown() ? (this.teleport ? 0.0625 : 0.0624) : 2.0E-8), PacketFly.mc.player.posZ + dArray[1], PacketFly.mc.player.rotationYaw, PacketFly.mc.player.rotationPitch, false));
        PacketFly.mc.player.connection.sendPacket(new CPacketPlayer.PositionRotation(PacketFly.mc.player.posX, -1337.0, PacketFly.mc.player.posZ, PacketFly.mc.player.rotationYaw, PacketFly.mc.player.rotationPitch, true));
        PacketFly.mc.player.connection.sendPacket(new CPacketEntityAction(PacketFly.mc.player, CPacketEntityAction.Action.START_FALL_FLYING));
        PacketFly.mc.player.setPosition(PacketFly.mc.player.posX + dArray[0], PacketFly.mc.player.posY + (PacketFly.mc.gameSettings.keyBindJump.isKeyDown() ? (this.teleport ? 0.0625 : 0.0624) : 1.0E-8) - (PacketFly.mc.gameSettings.keyBindSneak.isKeyDown() ? (this.teleport ? 0.0625 : 0.0624) : 2.0E-8), PacketFly.mc.player.posZ + dArray[1]);
        this.teleport = !this.teleport;
        PacketFly.mc.player.motionZ = 0.0;
        PacketFly.mc.player.motionY = 0.0;
        PacketFly.mc.player.motionX = 0.0;
        PacketFly.mc.player.noClip = this.teleport;
    }

    @SubscribeEvent
    public void onPacketReceive(PacketEvent.Receive receive) {
        if (PacketFly.fullNullCheck()) {
            return;
        }
        if (this.posLook.getValue() && receive.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook sPacketPlayerPosLook = receive.getPacket();
            if (PacketFly.mc.player.isEntityAlive() && PacketFly.mc.world.isBlockLoaded(new BlockPos(PacketFly.mc.player.posX, PacketFly.mc.player.posY, PacketFly.mc.player.posZ)) && !(PacketFly.mc.currentScreen instanceof GuiDownloadTerrain)) {
                if (this.teleportIds <= 0) {
                    this.teleportIds = sPacketPlayerPosLook.getTeleportId();
                }
                if (this.cancel.getValue() && this.cancelType.getValue()) {
                    return;
                }
                if (!(!this.cancel.getValue() || this.posLookPackets < this.cancelPacket.getValue() || this.onlyY.getValue() && (PacketFly.mc.gameSettings.keyBindForward.isKeyDown() || PacketFly.mc.gameSettings.keyBindRight.isKeyDown() || PacketFly.mc.gameSettings.keyBindLeft.isKeyDown() || PacketFly.mc.gameSettings.keyBindBack.isKeyDown()))) {
                    this.posLookPackets = 0;
                    receive.setCanceled(true);
                }
                ++this.posLookPackets;
            }
        }
    }

    @SubscribeEvent
    public void onPacketReceive(PacketEvent.Send send) {
        if (PacketFly.fullNullCheck()) {
            return;
        }
        if (this.scanPackets.getValue() && send.getPacket() instanceof CPacketPlayer) {
            CPacketPlayer cPacketPlayer = send.getPacket();
            if (this.packets.contains(cPacketPlayer)) {
                this.packets.remove(cPacketPlayer);
            } else {
                send.setCanceled(true);
            }
        }
    }

    private double[] getMotion(double d) {
        float f = PacketFly.mc.player.movementInput.moveForward;
        float f2 = PacketFly.mc.player.movementInput.moveStrafe;
        float f3 = PacketFly.mc.player.prevRotationYaw + (PacketFly.mc.player.rotationYaw - PacketFly.mc.player.prevRotationYaw) * mc.getRenderPartialTicks();
        if (f != 0.0f) {
            if (f2 > 0.0f) {
                f3 += (float)(f > 0.0f ? -45 : 45);
            } else if (f2 < 0.0f) {
                f3 += (float)(f > 0.0f ? 45 : -45);
            }
            f2 = 0.0f;
            if (f > 0.0f) {
                f = 1.0f;
            } else if (f < 0.0f) {
                f = -1.0f;
            }
        }
        double d2 = (double)f * d * -Math.sin(Math.toRadians(f3)) + (double)f2 * d * Math.cos(Math.toRadians(f3));
        double d3 = (double)f * d * Math.cos(Math.toRadians(f3)) - (double)f2 * d * -Math.sin(Math.toRadians(f3));
        return new double[]{d2, d3};
    }

    public enum PacketFlyMode {
        NONE,
        SETBACK

    }
}

